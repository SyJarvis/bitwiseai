# 大文件性能优化方案

## 问题

当互动小说包含大量节点（如几百上千个节点）时，一次性加载所有数据可能导致：

1. **页面加载缓慢**：大 JSON 文件需要较长时间解析
2. **内存占用高**：所有节点数据同时保存在内存中
3. **初始化延迟**：用户等待页面可用的时间变长

## 优化方案

### 方案 1：数据切片（推荐）

将剧情数据分成多个块，按需加载。

**优点**：
- 显著减少初始加载时间
- 降低内存占用
- 用户体验更流畅

**实现方式**：
1. 将节点按顺序分块（如每10个节点一块）
2. 初始只加载第一个数据块和节点索引
3. 当用户选择选项时，动态加载所需的数据块
4. 已加载的数据块缓存起来，避免重复加载

**示例数据结构**：

```json
{
  "metadata": {
    "title": "互动小说",
    "theme": "学习"
  },
  "nodeIndex": {
    "start": {"chunk": "chunk_0", "index": 0},
    "node1": {"chunk": "chunk_0", "index": 1},
    "node10": {"chunk": "chunk_1", "index": 0}
  },
  "chunks": ["chunk_0", "chunk_1", "chunk_2"]
}
```

**数据块示例**：

```json
{
  "chunk_0": [
    {"id": "start", "content": "...", "options": [...]},
    {"id": "node1", "content": "...", "options": [...]}
  ],
  "chunk_1": [
    {"id": "node10", "content": "...", "options": [...]}
  ]
}
```

### 方案 2：外部文件加载

将数据块存储为外部 JSON 文件，通过 fetch API 按需加载。

**优点**：
- 简化 HTML 文件大小
- 可以利用浏览器缓存
- 支持增量更新

**缺点**：
- 需要服务器环境（不能直接打开 HTML 文件）
- 网络请求可能增加延迟

**实现方式**：
```javascript
async function loadChunk(chunkId) {
  if (loadedChunks[chunkId]) {
    return loadedChunks[chunkId];
  }
  
  const response = await fetch(`data/${chunkId}.json`);
  const chunkData = await response.json();
  loadedChunks[chunkId] = chunkData;
  return chunkData;
}
```

### 方案 3：虚拟滚动

对于超长列表（如1000+个节点），只渲染可见部分。

**优点**：
- 适用于特别大的数据集
- 极致的性能优化

**缺点**：
- 实现复杂度高
- 对于剧情类应用可能过度设计

## 当前状态

目前技能使用的是**一次性加载所有数据**的方式。

**适合场景**：
- 节点数量 < 100
- 总数据大小 < 1MB
- 简单的使用场景

**不适合场景**：
- 节点数量 > 200
- 总数据大小 > 5MB
- 包含大量图片或资源

## 实施建议

### 短期方案（立即可用）

1. **控制故事长度**：
   - 将大故事拆分成多个独立的章节
   - 每个章节作为一个单独的互动小说
   - 使用"下一章"链接连接各章节

2. **优化数据格式**：
   - 压缩 JSON（删除不必要的空格和换行）
   - 使用简短的节点 ID
   - 避免重复内容

3. **预加载关键路径**：
   - 分析用户最常选择的路径
   - 预先加载这些路径上的节点
   - 其他路径延迟加载

### 中期方案（需要开发）

实现数据切片懒加载功能：

1. 修改 `generate_html.py` 脚本，支持数据切片
2. 在 HTML 中嵌入节点索引和数据块
3. 实现 JavaScript 懒加载逻辑
4. 添加加载进度提示

### 长期方案（架构升级）

1. **后端服务化**：
   - 将数据存储在数据库中
   - 提供 API 接口按需获取节点
   - 支持用户进度保存和恢复

2. **资源优化**：
   - 图片和音频按需加载
   - 使用 CDN 加速静态资源
   - 实现智能预加载策略

## 实施数据切片的步骤

如果需要实施数据切片功能，可以按照以下步骤：

1. **修改 `generate_html.py`**：
   - 将节点分块（如每10个节点一块）
   - 生成节点索引数据
   - 将数据块嵌入 HTML（或作为外部文件）

2. **实现 JavaScript 加载逻辑**：
   - `loadChunk(chunkId)`: 加载指定数据块
   - `getNode(nodeId)`: 获取节点（自动加载数据块）
   - `nodeCache`: 缓存已加载的节点

3. **更新 `goToNode` 函数**：
   - 改为异步函数
   - 使用 `await getNode(nodeId)` 获取节点
   - 处理加载状态和错误

4. **添加用户体验改进**：
   - 加载中提示
   - 进度条更新
   - 错误处理和重试

## 性能对比

| 方案 | 初始加载时间 | 内存占用 | 实现难度 |
|------|------------|---------|---------|
| 一次性加载 | 慢（大文件） | 高 | 简单 |
| 数据切片 | 快（仅索引） | 低（按需） | 中等 |
| 外部文件 | 快（仅索引） | 低（按需） | 中等 |
| 虚拟滚动 | 极快 | 极低 | 复杂 |

## 总结

对于大多数互动小说场景：
- **节点数 < 50**：当前方案完全够用
- **节点数 50-200**：考虑拆分章节或实施简单切片
- **节点数 > 200**：强烈建议实施数据切片懒加载

数据切片是性价比最高的优化方案，建议优先实施。
